<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >

<!-- ==================代理方式================= 由mapper标签开始，由/mapper结束，可以把它想成一个空间，是映射文件 
	属性namespace：空间名，主要在代理中使用。这个namespace是唯一的。 这里把mapper标签和接口联系在一起了，namespace=写接口路径，映射文件要和接口在同一目录下? -->
<mapper namespace="com.ccb.ProdPms.mapper.DmdManageMapper">

	<!-- =============映射关系标签============= 属性type:写po类的包名类名，由于之前定义了po类的别名，这里就写这个别名 
		属性id：是这个映射标签的唯一标识 id标签是查询结果集中的唯一标识，多列组成唯一标识则配置多个id 属性column：查询出来的列名 属性property：是po类里所指定的列名 
		通常会在原列名后面加下划线，这是固定的，这里就是id后面 column不做限制，可以为任意表的字段，而property须为type 定义的pojo属性 -->
	<resultMap id="DmdManageMap"
		type="com.ccb.ProdPms.entity.DmdManageEntity">
		<id column="id" property="id" jdbcType="INTEGER" />
		<result column="req_no" property="reqNo" jdbcType="VARCHAR" />
		<result column="req_name" property="reqName" jdbcType="VARCHAR" />
		<result column="req_source" property="reqSource"
			jdbcType="VARCHAR" />
		<result column="dept" property="dept" jdbcType="VARCHAR" />
		<result column="exec_type" property="execType"
			jdbcType="VARCHAR" />
		<result column="lead_team" property="leadTeam"
			jdbcType="VARCHAR" />
		<result column="coo_team" property="cooTeam" jdbcType="VARCHAR" />
		<result column="now_user" property="nowUser" jdbcType="VARCHAR" />
		<result column="next_user" property="nextUser"
			jdbcType="VARCHAR" />
		<result column="create_user" property="createUser"
			jdbcType="VARCHAR" />
		<result column="req_status" property="reqStatus"
			jdbcType="VARCHAR" />
		<result column="create_date" property="createDate"
			jdbcType="DATE" />
		<result column="modi_date" property="modiDate" jdbcType="DATE" />
	</resultMap>

	<!-- ==================定义sql片段============== sql:是sql片段标签属性,可被其他语句引用的可重用语句块 
		id是该片段的唯一标识 -->
	<sql id="Basic_Req_Columns">
		id, req_no, req_name,req_source,dept,exec_type,lead_team,
		coo_team,next_user,req_status,create_date,create_user,modi_date
	</sql>

	<!--mybatis进行数据库连接操作时对于SQL语句返回结果的处理有两种方式，resultType和resultMap resultType：对于SQL语句查询出的字段在相应的pojo中必须有和它相同的字段对应，而resultType中的内容就是pojo在本项目中的位置，适合单标查询 
		但是，如果在写pojo时，不想用数据库表中定义的字段名称，也是可以使用resultMap进行处理对应的。 多表连接查询时，若是一对一的查询，需要新建一个pojo，包括两个表中需要查询出的所有的字段，处理方式通常为创建一个继承一个表字段的pojo，在里面添加另 
		一个表内需要查询出的字段。既mapper.xml中采用association节点元素进行对另一个表的连接处理。若是一对多查询，若是使用内连接查询，则很可能出现 
		查询出的字段有重复。使用双重for循环嵌套处理。 extends+collection。 resultMap：需要在XxxMapper.xml中定义resultMap进行pojo和相应表字段的对应。 -->

	<!-- 增删改查标签里的id:一定要和接口里对应的方法名一致 resultMap输出类型里写映射标签里的id parameterType：输入类型，规范输入数据类型，指明查询时使用的参数类型 -->
	<!-- 获取全部需求列表 -->
	<select id="getAll" resultMap="DmdManageMap">
		select
		<include refid="Basic_Req_Columns" />
		from req
		where is_deleted = 0
	</select>
	<!-- 获取需求总数 -->
	<select id="selectCount" resultType="java.lang.Integer">
		select
		COUNT(id)id
		from req
	</select>
	<!-- 获取最后一个需求的id值 -->
	<select id="getLastId" resultType="java.lang.Integer">
		select
		id
		from req
		order by id
		desc limit 1
	</select>

	<!-- 什么时候用where，什么时候用<where>标签？ 查询的时候如果某些条件没有，可能sql拼装会有问题 解决办法： 1.给where 
		后面加上1=1，以后的条件都and   2.mybatis 使用where标签将所有的查询条件包括在内。where元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。 
		mybatis会将where标签后面第一个and去掉，只会去掉第一个多出来的and或者or。 -->
	<!-- 模糊检索+高级检索 -->
	<select id="getByParams" resultMap="DmdManageMap"
		parameterType="com.ccb.ProdPms.entity.DmdQueryParamsEntity">
		<!-- 用include标签引入sql片段，refid写定义sql片段的id，where标签不要写在片段里，如果refid指定的id不在本mapper文件中，需要前边加namespace -->
		select
		<include refid="Basic_Req_Columns" />
		from req
		<where>
			<!-- 当页面没有输入用户名和选择权限，就让它的条件永远为真，就变成全查询了，这里后面看管理页面能不能合并查询和初始化的sql用？ -->
			<!-- <if test="username == null and username = '' and upower == -1"> and 
				1=1 </if> -->
			<if test="reqNo != null and reqNo !=''">
				and req_no LIKE '%${reqNo}%'
			</if>
			<if test="reqName != null and reqName !=''">
				and req_name LIKE '%${reqName}%'
			</if>
			<if test="reqSource != null and reqSource !=''">
				and req_source LIKE '%${reqSource}%'
			</if>
			<if test="dept != null and dept !=''">
				and dept LIKE '%${dept}%'
			</if>
			<if test="execType != null and execType !=''">
				and exec_type LIKE '%${execType}%'
			</if>
			<if test="leadTeam != null and leadTeam !=''">
				and lead_team LIKE '%${leadTeam}%'
			</if>
			<if test="nextUser != null and nextUser !=''">
				and next_user LIKE '%${nextUser}%'
			</if>
			<if test="reqStatus != null and reqStatus !=''">
				and req_status LIKE '%${reqStatus}%'
			</if>
			<if test="beginDate != null and endDate !=null">
				and createDate between #{beginDate,jdbcType="Date"} and
				#{beginDate,jdbcType="Date"}
			</if>
			and is_deleted = 0
		</where>
	</select>

	<!-- 添加需求信息，参数的初始值在代码中做处理 -->
	<insert id="insert"
		parameterType="com.ccb.ProdPms.entity.DmdManageEntity">
		insert into
		req
		(req_no,req_name,req_source,dept,exec_type,lead_team,coo_team,now_user,next_user,req_status,create_date,create_uesr,modi_date,is_deleted)
		values (#{reqNo,jdbcType=VARCHAR},
		#{reqName,jdbcType=VARCHAR},#{reqSource,jdbcType=VARCHAR},
		#{dept,jdbcType=VARCHAR},
		#{execType,jdbcType=VARCHAR},#{leadTeam,jdbcType=VARCHAR},#{cooTeam,jdbcType=VARCHAR},
		#{nowUser,jdbcType=VARCHAR},
		#{nextUser,jdbcType=VARCHAR},
		#{reqStatus,jdbcType=VARCHAR},now(), #{createUser,jdbcType=VARCHAR},
		null, #{isDeleted,jdbcType=INTEGER})
	</insert>

	<!-- 添加新增需求时候的上传文档, 多份 -->
	<insert id="insertUpload"
		parameterType="com.ccb.ProdPms.entity.UploadFileEntity">
		insert into
		upload_file
		(file_name,path,type,user,is_deleted,req_no,datetime)
		values
		(#{fileName,jdbcType=VARCHAR},
		#{path,jdbcType=VARCHAR},#{type,jdbcType=VARCHAR},
		#{user,jdbcType=VARCHAR},#{isDeleted,jdbcType=INTEGER},#{reqNo,jdbcType=VARCHAR},now())
	</insert>

	<!-- 添加指定需求对应的需求项, 一对多关系，keyProperty的id就是我们要返回的主键id -->
	<!-- 执行这里的时候，一直不报错，但是数据无法插入到数据库中，最后原因是req_item_desc大小写在entity中没有写对，导致get方法无法获取到值，造成sql执行异常，但是为什么没报错这点需要继续查？ -->
	<insert id="insertDmdItem"
		parameterType="com.ccb.ProdPms.entity.DmdItemEntity"
		useGeneratedKeys="true" keyProperty="id">
		insert into
		req_item
		(req_no,req_item_name,req_item_desc,online_datetime,req_item_dev,req_item_status,create_time,change_time,op_person,is_deleted)
		values
		(#{reqNo,jdbcType=VARCHAR},
		#{reqItemName,jdbcType=VARCHAR},#{reqItemDesc,jdbcType=VARCHAR},now(),#{reqItemDev,jdbcType=VARCHAR},
		#{reqItemStatus,jdbcType=VARCHAR},now(),null,#{opPerson,jdbcType=VARCHAR},0)
	</insert>

	<!-- <insert id="insertSelective" parameterType="com.winter.model.User"> 
		insert into t_user <trim prefix="(" suffix=")" suffixOverrides=","> <if test="userId 
		!= null"> user_id, </if> <if test="userName != null"> user_name, </if> <if 
		test="password != null"> password, </if> <if test="phone != null"> phone, 
		</if> </trim> <trim prefix="values (" suffix=")" suffixOverrides=","> <if 
		test="userId != null"> #{userId,jdbcType=INTEGER}, </if> <if test="userName 
		!= null"> #{userName,jdbcType=VARCHAR}, </if> <if test="password != null"> 
		#{password,jdbcType=VARCHAR}, </if> <if test="phone != null"> #{phone,jdbcType=VARCHAR}, 
		</if> </trim> </insert> -->

	<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
	<!-- 修改用户信息 -->
	<!-- <update id="update" parameterType="com.po.UserinfoPO"> update userinfo 
		set loginname=#{loginname},loginpass=#{loginpass},username=#{username}, upower=#{upower},birthday=#{birthday},sex=#{sex} 
		where userid=#{userid} </update> -->
	<!-- <update id="updateByPrimaryKeySelective" parameterType="com.winter.model.User"> 
		update t_user <set> <if test="userName != null"> user_name = #{userName,jdbcType=VARCHAR}, 
		</if> <if test="password != null"> password = #{password,jdbcType=VARCHAR}, 
		</if> <if test="phone != null"> phone = #{phone,jdbcType=VARCHAR}, </if> 
		</set> where user_id = #{userId,jdbcType=INTEGER} </update> -->
	<!-- 解决mysql自增id不连续 -->
	<update id="alterTableAutoIncre" parameterType="string"
		>
		alter table ${_parameter} auto_increment=1
	</update>
	<!-- 假删除需求 -->
	<update id="deleteById" parameterType="java.lang.Integer">
		update req set
		is_deleted =
		1
		where
		id = #{Id,jdbcType=INTEGER}
	</update>
</mapper>
